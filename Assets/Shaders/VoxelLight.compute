// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SetXYPlane
#pragma kernel SetZPlane
#pragma kernel CBDR
#include "CGINC/Plane.cginc"

#define RES 16
#define ZRES 128
#define STEP 0.0625
#define ZSTEP 0.0078125
#define VOXELSIZE uint3(RES, RES, ZRES)
#define MAXLIGHTPERCLUSTER 16

struct PointLight{
    float3 lightColor;
    float lightIntensity;
    float4 sphere;
};

float4x4 _InvVP;
float3 _CameraForward;
float3 _CameraNearPos;
float3 _CameraFarPos;
uint _PointLightCount;

RWTexture3D<float4> _XYPlaneTexture;
RWTexture2D<float4> _ZPlaneTexture;
RWTexture3D<int2> _PointLightTexture;
StructuredBuffer<PointLight> _AllPointLight;
RWStructuredBuffer<uint> _PointLightIndexBuffer;

inline uint GetIndex(uint3 id, const uint3 size){
    return size.x * size.y * id.z + size.x * id.y + id.x;
}

[numthreads(RES, RES, 1)]
void SetXYPlane (uint2 id : SV_DispatchThreadID)
{
    float2 leftBotUV = (id / (float)RES);
    float2 rightTopUV =  leftBotUV + STEP;
    leftBotUV = leftBotUV * 2 - 1;
    rightTopUV = rightTopUV* 2 - 1;
    _XYPlaneTexture[uint3(id, 0)] = GetPlane(mul(_InvVP, float4(-1, rightTopUV.y, 0, 1)), mul(_InvVP, float4(1,rightTopUV.y, 0, 1)), mul(_InvVP, float4(0, rightTopUV.y, 0.5, 1)));                  //TOP
    _XYPlaneTexture[uint3(id, 1)] = GetPlane(mul(_InvVP, float4(1, leftBotUV.y, 0, 1)),  mul(_InvVP, float4(-1, leftBotUV.y, 0, 1)), mul(_InvVP, float4(0, leftBotUV.y, 0.5, 1)));                  //DOWN
    _XYPlaneTexture[uint3(id, 2)] = GetPlane(mul(_InvVP, float4(leftBotUV.x, -1, 0, 1)), mul(_InvVP, float4(leftBotUV.x, 1, 0, 1)), mul(_InvVP, float4(leftBotUV.x, 0, 0.5, 1)));        //LEFT
    _XYPlaneTexture[uint3(id, 3)] = GetPlane(mul(_InvVP, float4(rightTopUV.x, 1, 0, 1)), mul(_InvVP, float4(rightTopUV.x, -1, 0, 1)), mul(_InvVP, float4(rightTopUV.x, 0, 0.5, 1)));            //RIGHT
}

[numthreads(ZRES, 1, 1)]
void SetZPlane(uint id : SV_DISPATCHTHREADID)
{
    float3 backPos = lerp(_CameraNearPos, _CameraFarPos, id / (float)ZRES);
    float3 forwardPos = lerp(_CameraNearPos, _CameraFarPos, (id + 1.0) / (float)ZRES);
    _ZPlaneTexture[uint2(id, 0)] = GetPlane(-_CameraForward, backPos);
    _ZPlaneTexture[uint2(id, 1)] = GetPlane(_CameraForward, forwardPos);
}

[numthreads(RES,RES,1)]
void CBDR(uint3 id : SV_DISPATCHTHREADID)
{
    float4 planes[6];
    uint i;
    [unroll]
    for(i = 0; i < 4; ++i)
    {
        planes[i] = _XYPlaneTexture[uint3(id.xy, i)];
    }
    planes[4] = _ZPlaneTexture[uint2(id.z, 0)];
    planes[5] = _ZPlaneTexture[uint2(id.z, 1)];
    //TODO
    //
    uint clusterCount = 0;
    uint sBufferIndex = GetIndex(id, VOXELSIZE);
    for(i = 0; i < _PointLightCount && clusterCount < MAXLIGHTPERCLUSTER; ++i){
        PointLight lit = _AllPointLight[i];
        if(SphereIntersect(lit.sphere, planes) > 0.5){
            _PointLightIndexBuffer[sBufferIndex + clusterCount] = i;
            clusterCount++;
        }
    }
    _PointLightTexture[id] = uint2(sBufferIndex, sBufferIndex + clusterCount);
}